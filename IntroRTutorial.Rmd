---
title: "Introduction to R: Tutorial"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library("shiny")
library("learnr")
knitr::opts_chunk$set(echo = FALSE)
tutorial_options(exercise.cap = "Code", exercise.eval = FALSE, exercise.timelimit = NULL, exercise.lines = 3, exercise.checker = FALSE, exercise.completion = TRUE, exercise.diagnostics = TRUE, exercise.startover = TRUE)  
```

## INTRODUCTION  
### About this tutorial  

This Introduction to R e-learning tutorial is a part of Natural England's training material on using the R programming langauge to undertake statistical analysis.  This tutorial will help you to understand the syntax and concepts of the R language.  After completing the course you should be able to:

* understand the main data types in R: vector, matrix, data frame.  
* be able to import data from common file formats
* be able to work with functions and know where to find information on new functions
* be able to manipulate data with mathematical and logical operators
* undertake simple statistical analysis on your data
* make basic graphs

This will give you the grounding to follow the statistical case study examples that are being developed and to apply the techniques to your own data.

(Last updated: 30 October 2017)

###Target audience
The course is suitable for anyone who wants to be able to undertake statistical analysis themselves.

## How to use this tutorial
This tutorial is interactive.  It includes some explanation, but will also ask you to discover how **R** works by executing **R** code in exercises, or through quizzes. You will be able to try out your quiz answers before you submit your solution.  

The content of each section will be progressively revealed: Click **Continue** or **Next topic** to move forward.  You will get most out of the training if you complete all the exercises.  

Whilst you may wish to [install **R** and **RStudio**](http://trim/HPRMWebClientClassic/download/?uri=3571239) prior to starting this training course so that you can apply what you have learnt as you go along, having the software installed is not essential to running the interactive tutorials.

You may find it helpful to view the introductory video to R and R Studio before you start this tutorial: [Overview of R and R Studio](need link) (Duration xx minutes)

##Understanding code formatting
This tutorial includes **R** code which is always formatted like this: `this is what R code looks like` or as a separate chunk of code (which looks more like it does in RStudio):

```{r echo=TRUE, eval=FALSE}
This is what an R code chunk looks like.  
```

The output which R generates is presented like this: 
```{r}
print("This is what R output looks like.")
```

Some excercises require you to write code. Here's some example code.  Pressing **Run Code** will make R read and execute the code. Try it now: 
```{r intro, exercise=TRUE}
print("Pirates say R")
```

In **R**, any text to the right of a hash `#` is ignored by the **R** programme.  It is used to write **comments** addressed to the human reading the code. 
```{r, echo=TRUE}
#This is a comment. R will print it, but ignore it. 
#pssst: R is a silly name for a programme. Don't tell R.   
```

Click **Next topic** to view the contents of this tutorial.  

##CONTENTS

* Section 1: [R data types](#section-section-1-r-data-types) (xx minutes)
* Section 2: [Importing data](#section-tutorial-2-importing-data) (xx minutes)
* Section 3: [Functions and operators](#section-tutorial-3-functions-and-operators) (xx minutes)
* Section 4: [Summary statistics](#section-tutorial-4-summary-statistics) (xx minutes)
* Section 5: [Plots and charts](#section-graphs) (xx minutes) 

Click **Next topic** to read on.  

## SECTION 1: R DATA TYPES

This session should take about **xx** minutes to complete.  It introduces the ways in which R handles data, namely: 

* Basic types (numeric, character and logical)
* Data structures (vectors, matrices and data frames)

###
Lets look at **basic types** first. 

##  Basic types

In **R** there are four basic types for data:

* Numeric 
* Character
* Logical
* Factors

###

###Numeric values
Any value which consists of only numbers is automatically treated as **numeric** data in **R**.  

The following code creates a variable called `height` which has a value of `180`.

```{r echo=T}
height <- 180
```

###

Typing the name of a variable displays its value.

```{r echo=T}
height

```

###

In **R** the basic building blocks of how data are stored are called **vectors**.  Vectors contain a list of values (e.g. a measurement, species name, presence/absence).  For example, if you import a table of data from Excel into R each column of data is stored as a vector.

You can *combine* a sequence of values to create a vector.  The combine function in **R** is `c()` and each value must be separated with a comma `,`.  

```{r echo=TRUE}
bird.counts <- c(15, 700, 300, 120)
```

```{r bird.counts}
bird.counts <- c(15, 700, 300, 120)
```

Run the following code to display the values held in `bird.counts`.
```{r numeric.values, exercise=TRUE, exercise.setup = "bird.counts"}
bird.counts
```

###

Hint: In **R** the full stop `.` character can be used as a separator in variable names instead of using an underscore `_` character.

###Character values
Any value which contains text is automatically treated as being **character** data.  You tell R something is a character by enclosing it in double `"char"` or single `'char'` quotes.   

```{r echo=TRUE}
species <- c("bellis perennis", "columba livia")  
```

```{r character.values-setup}
species <- c("bellis perennis", "columba livia")  
```

```{r character.values, exercise=TRUE}
species
```

###Logical values
A logical value can only be either `TRUE` or `FALSE`.  You can also use the abbreviation `T` or `F`.

```{r echo=T}
species.present <- c(TRUE, FALSE, FALSE, TRUE, FALSE)
```

```{r logical.values-setup}
species.present <- c(TRUE, FALSE, FALSE, TRUE, FALSE)
```

```{r logical.values, exercise=TRUE}
species.present
```

###Quiz
```{r quiz1, echo=FALSE}
quiz(caption = "Quiz: Data types",
  question("Which type of value is `10`.",
    answer("character"),
    answer("numeric", correct = TRUE),
    answer("logical"),
    incorrect = "Incorrect: `10` is a numeric value."
  ),
  question("Which of these values does R treat as being character data?",
    answer("`\"favourable condition\"`", correct = TRUE),
    answer("`2017`"),
    answer("`\"2017\"`", correct = TRUE),
    answer("`TRUE`"),
    incorrect = "Incorrect: **\"favourable condition\"** is treated as character. `2017` is treated as a numeric, however when put in quotes `\"2017\"` is treated as a character." 
  ) 
)
```

###Factors

We have not yet encountered **categorical** data. In **R** such data are known as **factors**.  

Data is categorical if its values belong to a collection of known, defined and non-overlapping classes (referred to as **levels**)

Common examples might be: 
 
* species lists
* habitat types
* survey squares
* etc.

###

Factors are useful where you need to group data as part of your analysis. They may contain numeric, characters or logical values.  The function `factor()` is used to convert a vector to a factor.  

In this example `taxonomic.group` contains four values, but only three three unique levels because `"graminoids"` is repeated.

```{r echo=T}
taxonomic.group <- factor(c("brophytes", "graminoids", "vascular plants","graminoids"))
taxonomic.group
```

###

For logical factors the values can only be `TRUE` or `FALSE`.

```{r echo=T}
species.present <- factor(c(TRUE, FALSE, FALSE, TRUE, FALSE))
species.present
```

###

Factors may also contain numeric values.

```{r echo=T}
abundance <- factor(c(5,0,0,1,0))
abundance
```

### Extracting values from vectors

In **R** you can create a vector containing a sequence of numbers using the colon `:` operator.

```{r extracting.values, exercise=TRUE}
1:10
```

If you want to access specific values from a vector you use square brackets.  For example, to access the first value from `bird.counts`, which contains the values `15, 700, 300, 120`, you would use:

```{r extracting.values2, exercise=TRUE, exercise.setup = "bird.counts"}
bird.counts[1]

```

To access a range of values you use a colon `:`.  For example, to access the first three values from `birds.counts` you would use:

```{r extracting.values3, exercise=TRUE, exercise.setup = "bird.counts"}
bird.counts[1:3]
```

### Question

```{r quiz2}
quiz(
  question("Which of the following would create a vector containing the values `5,6,7? (tick all answers that apply)",
    answer("`c(5,7)`", correct = F),
    answer("`c(5,6,7)`", correct = T),
    answer("`5:7`", correct=T),
    answer("`5,6,7`", correct = F),
    incorrect= "Not quite.  Try running each of the answers in the code block below and see which ones return the values `5,6,7`"
  )
)
```

Hint: Try running each of the answers in the code block below.

```{r quiz2.code, exercise=TRUE}

```

###
End of topic: **Basic types**

##Matrix

###What is a matrix?

A **matrix** consists of two or more *vectors* which must: 

* have the same length; and 
* contain the same type of data.

###Example: pitfall traps
You have four [pitfall traps](http://en.wikipedia.org/wiki/Pitfall_trap) and have counted how many invertebrates of two species are found in each. You found the following numbers of species in the traps:  

```{r echo=TRUE}
species.a <- c(11,19,33,12)
species.b <- c(9, 33, 27, 14)
```

###The bind functions
You can **bind** these two **vectors** into a **matrix**: 

```{r echo=TRUE}
trap.count <- cbind(c(11,19,33,12), c(9,33,27,14))
```

The `cbind` (**c**olumn **bind**) function combind the vectors into a matrix as columns.  You could also use `rbind` (**r**ow **bind**) to bind vectors as rows.  

###Matrix function
You can also coerce a single vector into a matrix by using the **matrix** function.  For this you need to specify the vector, and either: 

* the number of rows `nrow=` or  
* the number of columns `ncol=`  

which the matrix should have.  

###Example: weather records 
You have recorded monthly mean temperature at Thursley NNR for five years and have stored them into the vector `temp`:

```{r, echo=TRUE}
temp <- c(1.27, 3.68,  6.43,  9.32, 11.06, 16.14, 18.38, 16.16, 14.03, 10.85, 5.71, -0.01, 4.42,  6.66,  6.98, 12.62, 12.89, 14.72, 15.74, 16.31, 15.74, 12.96, 10.06, 6.44,  6.00,  3.81,  8.50, 7.90, 12.89, 14.52, 16.12, 17.38, 13.73, 10.38,  6.99,  5.35,  3.93,  3.25,  3.53,  7.91, 10.80, 14.50, 19.10, 17.70,
14.33, 12.89,  6.61,  6.26,  6.28,  6.97,  8.16, 10.62, 12.63, 15.94, 18.68, 15.86, 15.74, 13.31,  8.92,  5.40)
```

```{r, weather.records-setup}
temp <- c(1.27, 3.68,  6.43,  9.32, 11.06, 16.14, 18.38, 16.16, 14.03, 10.85, 5.71, -0.01, 4.42,  6.66,  6.98, 12.62, 12.89, 14.72, 15.74, 16.31, 15.74, 12.96, 10.06, 6.44,  6.00,  3.81,  8.50, 7.90, 12.89, 14.52, 16.12, 17.38, 13.73, 10.38,  6.99,  5.35,  3.93,  3.25,  3.53,  7.91, 10.80, 14.50, 19.10, 17.70,
14.33, 12.89,  6.61,  6.26,  6.28,  6.97,  8.16, 10.62, 12.63, 15.94, 18.68, 15.86, 15.74, 13.31,  8.92,  5.40)
```

###
You want to put these into a matrix where each row represents a month and each column a year.  You know they are in order, starting with January of the first year.  

###
You can do this by specifying the number of rows (12 months = 12 columns).  Click **Run Code** to see how it works: 

```{r weather.records,  exercise=TRUE, exercise.eval=FALSE}
matrix(temp, nrow= 12)
```

This creates a matrix with one row for each month and one column for each year.

###Exercise: another pitfall trap

You have inspected three pitfall traps and are recording the number of spiders and the number of ground beetles in each.  You want to create the following matrix:

```{r}
cbind(c(0,7,2),c(3,0,1))
```
###

```{r trap-ex-3}
quiz(
  question("How can you combine the data into a matrix like the one above? (tick all answers that apply)",
    answer("matrix(c(0,7,2,3,0,1))", correct = F),
    answer("cbind(c(0,7,2),c(3,0,1))", correct = T),
    answer("rbind(c(0,3),c(7,0),c(2,1))", correct = T),
    answer("matrix(c(0,7,2,3,0,1), nrow=3)", correct = T)
  )
)
```

Before you answer the question, use the empty code block below to try out the options.  Press **Run Code** to see the results.  
```{r block-trap-ex-3, exercise=TRUE, exercise.eval=T}

```
###
End of topic **Matrix**

## Data Frame

###What is a data frame?

A data frame consists of two or more **vectors** of the **same length**.  Unlike a matrix each column can contain **different types of data**.  It is the preferred way of storing tabular data in R.  It is also the default way data from Excel spreadsheets is imported into **R**.

###Example: vegetation quadrat


We have surveyed a 1m by 1m vegetation quadrat on a heathland.  We have estimated the area which each plant species covers in percent.  These are our results: 

plant | cover
:--- |:----
shrubs | 60%
grasses | 25%
mosses | 30%
flowers | 5%

### 
We can't combine this into matrix because *plants* and *cover* are different types of data.   

*Plants* is **character** data  
*Cover* is **numeric** data.   

###
However, we can bind these two vectors into a **data frame**: 

```{r echo=TRUE}
quadrat <- data.frame(plants = c("shrubs", "grasses", "mosses", "flowers"),
                      cover = c(60, 25, 30, 5))
```

```{r quadrat-setup}
quadrat <- data.frame(plants = c("shrubs", "grasses", "mosses", "flowers"),
                      cover = c(60, 25, 30, 5))
```

```{r quadrat, exercise=TRUE}
quadrat
```

###
The `data.frame` function combines the vectors into a data frame.  You could also use `cbind` and **R** would automatically create a `data.frame` because a matrix cannot contain vectors of different data types.

###Accessing data in data frames
You are likely to want to retrieve all or parts of the data in a data frame.  There are a number of ways of doing this: 

### All the data
As you have already seen the name of the object returns all the data.  E.g.: 

```{r, echo=TRUE}
quadrat
```

### Indexing columns by name

If you pass the name of the column in square brackets it will return the single column.

```{r, echo=TRUE}
quadrat["cover"]
```

###

The `$` sign is used to reference the values in a column and returns a vector.

```{r, echo=TRUE}
quadrat$cover
```

###

### Index referencing
Parts of a dataframe can be referenced by their **index**.  Think of it as co-ordinates, where the first index is the row and the second the column.  The index is enclosed in square brackets `[ROW, COLUMN ]`

###
A **single cell** is referenced by two numbers, and returns a single value.  

The following code returns the value is the third row of the second column:  

```{r, echo=TRUE}
quadrat[3,2]
```

###
A **single row** is referenced by one number, leaving the column reference blank. 

The following code returns the third row only:

```{r, echo=TRUE}
quadrat[3, ]
```

###
A **single column** is referenced by one number, leaving the row reference blank.  It returns a data frame with one column.  

```{r, echo=TRUE}
quadrat[2]
```

###
To access the values in the second column you leave the row reference blank.  It returns a vector containing the values.

```{r, echo=TRUE}
quadrat[,2]
```

### Referencing ranges
Ranges of rows or columns can also be addressed. 

The following code returns the first three rows of the second column as a vector.  

```{r, echo=TRUE}
quadrat[1:3,2]
```

###Exercise: extracting a column

You are asked to extract a species list from the quadrat you have surveyed.  

```{r veg-ex-2}
quiz(
  question("Which of the following will returns the species names? (tick all answers that apply)",
    answer("`quadrat[1]`", correct = T),
    answer("`quadrat[,1]`", correct = T),
    answer("`quadrat.plants`", correct = F),
    answer("`quadrat$plants`", correct = T),
    answer("`quadrat[\"plants\"]`", correct = T)
  )
)
```

Before you answer the question, use the empty code block below to try out the options.  Press **Run Code** to see the results.  Press **Hint** for more information.  
```{r block.veg.ex.2-setup}
quadrat <- data.frame(plants = c("shrubs", "grasses", "mosses", "flowers"),
                      cover = c(60, 25, 30, 5))
```

```{r block.veg.ex.2, exercise=TRUE}

```
<div id="block-trap-ex-3-hint">
Sorry, no hint this time.  Try out all the solutions and see which works. 
</div>


###Solution

* *Correct*: `quadrat[1]` You can index a column by its number, without specifying any rows.    
* *Correct*: `quadrat[,1]` You access values by specifying rows and columns: `[row , column]`.  Here we left the row index blank, which returns all rows, and the first column.    
* *Incorrect*: `quadrat.plants` **R** thinks this is an object called   `quadrat.plants`: we haven't defined such an object.   
* *Correct*: `quadrat$plants` The `$` character is used to reference a column name.
* *Correct*: `quadrat["plants"]` Here we have used a character string to reference a column by its name.     

###
End of topic **Data Frame**

## TUTORIAL 2: IMPORTING DATA  

This session should take about **xx** minutes to complete.  It gives a brief introduction to importing data from a text file.   

## The working directory

The working directory is the place R will look for any data, unless you tell it otherwise.  So first you need to set the working directory: 

###
`setwd("C:\\introR")`  

Windows uses backslashes `\`: in **R** these must be written twice `\\` (because a single backslash has a special meaning in **R**).   

###
`setwd("C:/introR")`  

Alternatively you can used single forward slashes `/` for paths.

###
End of topic **The working directory**

## Importing csv files

Data is often collated from sources such as: 

* field survey sheets
* sensor measurements
* third party data (e.g. weather records)

###Example

You want to understand the impact of grazing on a site, so you have measured the height of grasses, mosses and shrubs on five occasions in the last ten years.  

###
The easiest way of getting data into R is to read it from a text file,  for example a file saved as comma separated values in Excel (.csv). To make it easy for a beginner to deal with, the .csv file should have: 

* a single row at the top with header information
* data should be in columns
* observations should be in rows
* there should be no summary rows or columns

###The read.csv function

The **read.csv()** function can bring csv file data into **R**.  The code needs to have the following components: 

###
`read.csv()`  The function which will interpret the file and read it into **R**

###
`"veg-heights.csv"`  The name of the file you are importing.  Note that it is in quotes `""`: this is because we want **R** to read it as a string of characters.  

###
`header = TRUE`  An **parameter** for the `read.csv()` function.  We will learn more about parameters later.  

###
`veg.heights`  A name for the **object** we will read the file into.  If the object already exists **R** will overwrite it.  If it doesn't exist, **R** will create it. 

###
Here is the assembled line of code: 

```{r, echo=TRUE, eval=FALSE}
veg.heights <- read.csv("veg-heights.csv", header=TRUE)
```

###
End of topic **Importing csv files**

## Importing other formats

Data in text files is often separated by commas, but you may find other separators, most commonly tab separated values.  For these we need a different function:  

###
`read.table()`  It works just like `read.csv()` but you need to specify the separator.  

`sep = ""` An argument to specify the separator: here it specifies white space (including tabs).  

###
```{r, echo=TRUE, eval=FALSE}
veg.heights <- read.table("veg-heights.txt", sep="")
```

### Installing Excel files

By installing R extensions you can read data in other formats, such as Excel or spatial data from shapefiles. 

The package [xlsx](https://cran.r-project.org/web/packages/xlsx/index.html) can be installed from the R repository and includes functions for importing Excel files in xlsx format.  

First you will need to install the xlsx package as it is not part of the base R libraries.

`install.packages("xlsx")`

You should hopefully see a message telling you that the package and any dependencies have been successfully unpacked.

To use the package you must first load it from your library.

`library("xlsx")`

Hint:  On a Natural England laptop you may need to run the 32 bit version of R for this to work.

To read an Excel file use the following command.

`veg.heights <- read.xlsx("veg-heights.xlsx", 1)`

The first first argument "`veg-heights.xlsx`" is the name of the Excel file and the second argument `1` is the index of the worksheet that you wish to import.

###
End of topic **Importing other formats**

## Viewing data in R Studio
Once you have read in a file, in R Studio it will appear in the Global Environment window in the top right hand side.  

![RStudio's view of data that has been imported](images/introR_data_import.png){width="560"}

Clicking on the table icon to the right of the variable name will open a window showing its values.

###

end of topic **Importing data**

## TUTORIAL 3: FUNCTIONS AND OPERATORS  

This session should take about **xx** minutes to complete.  It explains:

* how functions work
* how to find help
* mathematical operators
* operations on R objects
* logical operators
* relational operators

## How do functions work

Functions are crucial tools in any programming language.  A function is a part of a computer program that performs some specific action.  

We have already encountered some R functions, such as `c`, `factor`, `cbind`, `data.frame()`, `read.csv()` and `read.txt()`. 

Let's look at the components of a function we've already used: 

###
![The components of a function](images/introR_functions.png){width="560"}

###
End of topic **How do functions work**

## How to find help

###
The following website provides a useful list of R's built in functions.

[Quick-R: Built-in Functions](http://www.statmethods.net/management/functions.html)

###

R has built in documentation to explain what functions do, and what their default parameters are.  

Putting a question mark in front of a function name displays its help. For example `?c` displays the help for the **combine** function.

Try to find help for the `cbind` function:

```{r help.ex, exercise = TRUE}

```

```{r help.ex-hint}
?cbind
```

If you've done it correctly the help file will pop up in a new window.  Click **Hint** above if you are struggling.  

###
End of topic **How to find help**

## Mathematical Operators

You can use **R** to carry out mathematical operations: 

###
```{r results="asis"}
mathops <- cbind(Operator = c("+", "-", "*", "/", "^", "sqrt", "log"), Description = c("Addition", "Subtraction", "Multiplication", "Division", "Exponent", "Square root", "Natural logarithm"))
knitr::kable(mathops, caption = "Mathematical Operators")
```

###
**R** evaluates mathematical operations: 
```{r echo = TRUE}
2*2
```

###
Normal arithmetic rules apply (if you are unsure, see [Order of Operations](http://en.wikipedia.org/wiki/Order_of_operations)): 
```{r echo = TRUE}
2*1+2
```

###
... so use brackets if necessary: 
```{r echo = TRUE}
2*(1+2)
```

### Exercise: mathematical operators


```{r mathops.ex.1}
quiz(
  question("Which of these calculations equals **20**? (tick all answers that apply)",
    answer("5+5*2", correct = F),
    answer("(5+5)*2", correct = T),
    answer("5+(5*2)", correct = F),
    answer("sqrt(400)", correct = T)
  )
)
```

Before you answer the question, use the empty code block below to try out the options.  Press **Run Code** to see the results.    
```{r block-mathops.ex.1, exercise=TRUE, exercise.eval=T}

```

###
End of topic **Mathematical Operators**

## Operations on R objects

Objects such as vectors and data frames can be manipulated with mathematical operations.    

### Example: water table
We have measured the water table (in cm) on a site once a month for a year:   

```{r echo=TRUE}
water.table <- c(20.4, 17.3, 22.5, 11.6, 3.6, 2.2, 4.6, 5.5, 12.4, 25.4, 17.3, 19.2)
```

###
We'd like to convert the readings from cm to metres, so we need to divide each value by 100.  We can simply divide the entire object by 100: 

```{r echo=TRUE}
water.table / 100
```

###
We repeat our measurements the following year:
```{r echo=TRUE}
water.table.rpt <- c(26, 15, 24.1, 10.1, 5.5, 0.4, 2.3, 5.9, 13.4, 28.1, 19.3, 18.7)
```

###
Now we'd like to know the the difference in water table between one year and the next.  We can just subtract one object from the other:  

```{r echo=TRUE}
water.table.rpt - water.table
```

###
Or we can calculate the difference and convert to metres in one line of code: 
```{r echo=TRUE}
(water.table.rpt - water.table)/100
```

### Example: pitfall trap

In a previous exercise we collected data from a pitfall trap and saved it into a matrix: 
```{r echo=TRUE}
trap.count <- cbind(c(11,19,33,12), c(9,33,27,14))
```

###
Now we'd like to calculate the log of each element in the matrix: 
```{r echo=TRUE}
log(trap.count) 
```

###
End of topic **Operations in R**

## Logical Operators

You can use **R** to carry out logical operations

|Operator |Description |
|:--------|:-----------|
|!        |NOT         |
|&        |AND         |
|&#124;   |OR          |


### Logical vectors

You can create logical vectors: 
```{r echo = T}
x <- c(TRUE, FALSE, FALSE, TRUE)
y <- c(FALSE, TRUE, FALSE, TRUE)
```

``` {r echo = T}
x
y
```

### NOT
`!` **NOT** inverts the logical value of an object.  
``` {r echo = T}
!x
```
Here it has inverted each element of the vector `x`

### AND
`&` **AND** compares two elements and returns `TRUE` if they are both `TRUE` and `FALSE` if one or both of them are `FALSE`  Again, it will operate on each element of two vectors and compare them:
``` {r echo = T}
x&y
```

### OR
`|` **OR** returns `TRUE` if either or both elements are `TRUE`; and `FALSE` if both elements are `FALSE`: 
``` {r echo = T}
x|y
```


### Exercise: Heathland burning

On five heathland plots you have recorded:  

* the presence of Heath Star-moss *campylopus introflexus*; and  
* whether there is evidence of burning.  

This is what you found: 


```{r echo = F}
burn <- c(FALSE, TRUE, FALSE, FALSE, TRUE)
moss <- c(TRUE, TRUE, FALSE, FALSE, TRUE)
burnmoss <- cbind(burn = burn, moss = moss)
knitr::kable(burnmoss)
```

###
You have saved the results into two vectors: 
```{r echo = T}
burn <- c(FALSE, TRUE, FALSE, FALSE, TRUE)
moss <- c(TRUE, TRUE, FALSE, FALSE, TRUE)
```

###
Now you'd like to know on which plots there was both burning and the moss.  

```{r heath.ex}
quiz(
  question("Which logical statement finds the plots where there was both burning and the moss? (one correct answer)",
    answer("`burn | moss`", correct = F),
    answer("`burn & moss`", correct = T),
    answer("`burn & !moss`", correct = F)
  )
)
```

###Solution

![OR](images/introR_OR.png){height="80"}

*Incorrect* `burn | moss` burn **OR** moss returns `TRUE` for each plot that has been burned, or there is moss, or both. It returns all plots. 

![AND](images/introR_AND.png){height="80"} 

*Correct* `burn & moss` burn ** AND** moss returns` TRUE` only if a plot has been burned and there is moss

![NOT](images/introR_NOT.png){height="80"} 

*Incorrect* `burn & !moss` burn **NOT** moss returns `TRUE` only if a plot has been burned but there is no moss.

###
End of topic **Operations in R**

##Relational Operators

You can use **R** to compare two elements. 


|Operator |Description |
|:--------|:-----------|
|<        |Less than |
|>        |Greater than |
|<=       |Less than or equal to |
|>=       |Greater than or equal to|
|==       |Equal to|
|!=       |Not equal to|

###
Lets create two objects with different values... 
```{r echo = T}
x <- 5
y <- 16
```

###
... and investigate what each operator does: 
```{r echo = T}
x < y
y > x
x <= 5
y >= 16
y == 2
x != 4999
```

###
As with logical operations, you can also apply relational operators to vectors, matrices and data frames.   

###
Lets repeat the steps above, but with vectors: 
```{r echo = T}
x <- c(1, 2, 3)
y <- c(3, 2, 1)
```

###
... and investigate what each operator does: 
```{r echo = T}
x < y
y > x
x <= 5
y >= 16
y == 2
x != 2
```

###
Notice that the operation returns a logical **vector**.  If you did this with two data frames, it would return a data frame. 

###Example: deer counts
We have carried out a deer count at three survey locations.  We repeated it the following year.  We wish to know for each species, whether the number of deer has decreased: 

###
First we make two data frames with our data: 
```{r echo = TRUE}
deer1 <- data.frame(red = c(5, 17, 28), roe = c(33, 35, 75))
deer2 <- data.frame(red = c(7, 15, 50), roe = c(20, 22, 61))

deer1
deer2
```
Note that we have given the columns names using this syntax: `red =` and `roe =`

###
We then use the relational operator to compare the two data frames: 
```{r echo=TRUE}
deer1 > deer2
```
Note that the operation returns a logical data frame of identical dimensions.  


###Exercise: water table

We want to find the months in which the water table (from our earlier exercise) in our second survey was lower than in our first survey.  

###
First we'll subtract the first reading from the second reading:
```{r echo=TRUE}
water.table.diff <- water.table.rpt - water.table
water.table.diff
```


###
Now write code which will give a logical vector where `TRUE` means the water table in the second survey was lower than in the first: 


```{r watertb-setup}
water.table <- c(20.4, 17.3, 22.5, 11.6, 3.6, 2.2, 4.6, 5.5, 12.4, 25.4, 17.3, 19.2)
water.table.rpt <- c(26, 15, 24.1, 10.1, 5.5, 0.4, 2.3, 5.9, 13.4, 28.1, 19.3, 18.7)
water.table.diff <- water.table.rpt - water.table
water.table.diff
```

```{r watertb, exercise = TRUE}

```

```{r watertb-hint-1}
you can use water.table.diff and find differences smaller than 0  
```

```{r watertb-hint-2}
or you can compare water.table and water.table.rpt  
```

###Solution
There were a number of possibilities: 

```{r echo = T}
water.table.diff < 0
0 > water.table.diff
water.table > water.table.rpt
```

###
End of topic **Functions and operators**

## TUTORIAL 4: STATISTICS  

This session should take about **xx** minutes to complete.  It gives a very brief introduction to calculating statistics from **R**

## Summary statistics

Using the water.table data as an example this section shows how you can calculate summary statistics.

```{r echo=TRUE}
water.table <- c(20.4, 17.3, 22.5, 11.6, 3.6, 2.2, 4.6, 5.5, 12.4, 25.4, 17.3, 19.2)
```

`sd`: Standard deviation tells us  how values in the sample are spread out from the sample mean:

```{r echo=TRUE}
sd(water.table)
```

###
`mean`: the mean is the average of all values
```{r echo = T}
mean(water.table)
```

###
`median`: the median is the middle value of all values when you put them in order: 
```{r echo = T}
median(water.table)
```

###
`max`: the maximum is the highest value:
```{r echo = T}
max(water.table)
```

###
`min`: the minimum is the lowest value: 
```{r echo = T}
min(water.table)
```

###
`quantile`: quantiles are the value at a given probability, e.g. 25% of (one in four ) measurements are likely to be at 5.275cm or below.  
```{r echo = T}
quantile(water.table)
```

### 
`sum`: is the total of all the values.  For water table depth it wouldn't make much sense to calculate the sum of the values.
```{r echo = T}
sum(water.table)
```

###
`summary`: shows summary statistics for an object.  For a vector containing numeric values it returns the minimum and maximum, mean, median and quartile values:
```{r echo = T}
summary(water.table)
```

### Exercise: water table range
We'd like to know how big, in centimetres, the range is between the lowest and the highest measured water table.  Write **R** code to calculate this. 

```{r waterrange-setup}
water.table <- c(20.4, 17.3, 22.5, 11.6, 3.6, 2.2, 4.6, 5.5, 12.4, 25.4, 17.3, 19.2)
```

```{r waterrange, exercise=TRUE, exercise.setup = "waterrange-setup"}

```


```{r waterrange.2}
quiz(
  question("What is the range in the water table? (one correct answer)",
    answer("23.5", correct = F),
    answer("23.3", correct = F),
    answer("23.2", correct = T)
  )
)
```

### Solution

The easiest way to calculate this is to subtract the minimum from the maximum: 
```{r echo=TRUE}
max(water.table) - min(water.table)
```

###
End of topic **Summary statistics**

## Missing Values

Missing values occur all too frequently: 

* a sensor might fail or a battery run out
* part of a site is temporarily inaccessible
* the surveyor's handwriting is hard to read
* someone forgot to write a measurement down!

In **R** 'Not available' or missing values are specified using `NA`

```{r echo=TRUE}
veg.heights <- c(44.2,22.7,NA,33.3)
veg.heights
```

###
This can cause problems, for instance when calculating the mean: 
```{r echo=TRUE}
mean(veg.heights)
```
  
###
The mean cannot be calculated because the missing value is included.  However, you can tell **R** to ignore missing values using the parameter:  

`na.rm = TRUE` (it stands for *remove NA*)

###
```{r echo=TRUE}
mean(veg.heights, na.rm = TRUE)
```
It has calculated the mean.  

###
end of topic **Missing Values**

## Exercise: birds
A school has been recording birds in its neighbourhood.   They have asked you to analyse the results. The data have been imported and saved to the variable `birds`.

`birds <- import.csv("birds.csv")`

```{r block10-setup}
birds <- data.frame(species = c("duck", "gull", "lapwing", "nuthatch", "owl", "robin", "sparrow", "tit" ), 
               farm = c(10,5,2,0,0,0,7,2),
               garden = c(7,0,0,0,0,3,0,6), 
               wood = c(0,0,0,4,2,0,0,8)
               )
```

```{r echo=TRUE}
birds
```

###

```{r birds.obj.ex.2}
quiz(
  question("How would you calculate the total number of birds seen? (one correct answer)",
    answer("`sum(birds)`", correct = F),
    answer("`birds$farm + birds$garden + birds$wood`", correct = F),
    answer("`sum(birds$farm, birds$garden, birds$wood)`", correct = T)
  )
)
```

Before you answer the question, use the empty code block below to try out the options.  Press **Run Code** to see the results and **Hint** if you are stuck.    
```{r block-birds.obj.ex.2-setup}
birds <- data.frame(species = c("duck", "gull", "lapwing", "nuthatch", "owl", "robin", "sparrow", "tit" ), 
               farm = c(10,5,2,0,0,0,7,2),
               garden = c(7,0,0,0,0,3,0,6), 
               wood = c(0,0,0,4,2,0,0,8)
               )
```

```{r block-birds.obj.ex.2, exercise=TRUE}

```

```{r block-birds.obj.ex.2-hint}
"Have another look at the section Accessing data in data frames"
``` 

### Solution

* *Incorrect* `sum(birds)`  This function is a good choice because it adds all the numbers in a dataframe.  But here you are also inadvertently telling R to add up the names of the birds (in the column 'Species')
* *Incorrect* `birds$farm + birds$garden + birds$wood` Here you are actually making a new vector made up of the three columns of bird observations.
* *Correct* `sum(birds$farm, birds$garden, birds$wood)` Sum is being told to add all the numbers in the three columns of bird numbers. 

###
end of topic: **Exercise: birds**

## Statistical tests

This section will give you a brief introduction to undertaking statistical tests in **R**.  More detail on specific statistical tests is provided in the case studies.

Let's look at the vegetation heights data again:  

###
```{r echo=TRUE}
veg.all <- read.csv("veg-all.csv", header=TRUE)
```

### 
You can view all the data by typing `View(veg.all)`:
```{r echo=TRUE}

```

###
Using the function `summary` you can get an idea of which variables are in the data. 
```{r echo=TRUE}
summary(veg.all)
```

###

From the summary you can see that the data contains heights and cover for grasses, mosses and shrubs for years between 2003 and 2013. If you wanted to look at each of these separately you could use the ``subset`` function.

```{r echo=TRUE}
veg.grasses <- subset(veg.all, taxon=="grasses")
```
The above code extracts just the heights for grasses and stores the data in a variable called `veg.grasses`.


Whilst the summary statistics are useful, it is often easier to show data on graph.  Boxplots are good for visualising the spread of values.

```{r echo=TRUE}
boxplot(height ~ factor(year), data=veg.grasses)
```

The [Graphs](#section-graphs) section provides more information on producing plots in **R**. In the code above `year` has been converted to a factor so that **R** knows that it should be interpreted as categorical data rather than as continuous values.

###

Visually there appears to be a difference in the vegetation heights of grasses between some of the years.

If you wanted to test the hypothesis that there is a difference between the heights you could use a statistical test.  To perform an ANOVA test you would use the following code.

```{r echo=TRUE}
aov(height ~ factor(year), data=veg.grasses)
```

In this case the results are inconclusive (no significant result) so we cannot reject the null hypothesis that there may not be a difference in the heights.  This is actually because the data are not normally distributed with common variance so not suitable for a parametric test.  

###

Using a non-parametric test produces a significant result, p < 0.05, indicating that there is a difference in vegetation height between at least two of the years.

```{r echo=TRUE}
kruskal.test(height ~ factor(year), data=veg.grasses)
```

The case study on comparing means **[link]** goes through this example in more detail.

###
end of topic **Statistics**

##RANDOM DISTRIBUTIONS

This session should take about **xx** minutes to complete.  It will introduce a number of statistical distributions, the generations of random numbers and how to prepare simple plots and charts in **R**

##Generating random numbers

Generating random numbers can be useful in collecting and analyising ecological data.  At its simplest, we often need to generate random survey points to ensure our surveys are not biased.  You may also need to generate random numbers which are distributed in particular ways in order to compare it against collected data and test for randomness.   

###
You can generate random numbers in R in a variety of ways:

###
`sample` draws random numbers from a sample.  Here we have drawn 10 numbers at random from a sample of whole numbers between  1 and 100, e.g. to select ten random survey points along  a 100m transect.
```{r echo=TRUE}
sample(x = 1:100, size = 10, replace = F)
```

###
**R** has a series of functions which generate random numbers drawn from a series of statistical distributions.  We will have a look at each function, plot it and consider where it might be relevant.  The functions in question are: 

`runif`: random, uniform distribution
`rnorm`: random, normal distribution
`rpois`: random, poisson distribution
`rexp`: random, exponential distribution


### Uniform distribution
`runif` stands for random uniform - meaning it selects randomly (between the minimum and maximum numbers given) using a uniform distribution.  
```{r echo=TRUE}
runif(n = 5, min = 0, max = 1)
```

###
Lets plot a histogram of this, with the function `hist`: 
```{r echo=TRUE}
hist(runif(n = 5, min = 0, max = 10))
```

###
In the uniform distribution, every number has equal chance of being generated.  So when there is sufficient random data, every part of the number range will be roughly evenly represented.
```{r echo=TRUE}
hist(runif(n = 10000, min = 0, max = 10))
```

### Normal distribution
This is a small sample from a normal distribution with a mean of 0.5 and a standard deviation of 0.1. 
```{r echo=TRUE}
rnorm(n = 10, mean = 0.5, sd = 0.1) 
```

###
When repeated with 10000 random numbers we see the typical bell  shape of the normal distribution.
```{r echo=TRUE}
hist(rnorm(n = 10000, mean = 0.5, sd = 0.1)) 
```

### Poisson distribution
The poisson distribution's characteristic skewedness and long tail.  Typical of independent events that have occasional extremes, such as the water table in a river that occasionally floods.
```{r echo=TRUE}
hist(rpois(10000, lambda = 0.5))  
```

### Exponential distribution
The exponential is typical of events which change at a continuous rate, for instance the decrease in light under a forest canopy.
```{r echo=TRUE}
hist(rexp(n = 10000))
```


## GRAPHS
**R** produces great plots, but unlike other software you need to tell **R** in writing how the plot should look.

###
Lets look at the vegetation heights data again.  
```{r veggraph-setup}
veg.all <- read.csv("veg-all.csv", header=TRUE)
```

So now we can start plotting the data with a function called ... `plot`.  

###
When using the `plot` function R automatically selects an appropriate graph type, depending on the data.  Here it has chosen to plot all variables against each other. It can provide a quick way of choosing what to plot next.  
```{r echo=TRUE}
plot(veg.all)
```

###
Lets look at the variables `height` and `cover`.  Here we are defining the axes as a `formula` and specifying the data source. 
```{r echo=TRUE}
plot(formula = height ~ cover, data = veg.all)
```

###
Do you think there is a relationship between vegetation height and cover here? 

###
Now lets look at `height` and `year`.  Perhaps there is change over time? 
```{r echo = TRUE}
plot(height ~ year, veg.all)
```

Note that we have left out the names of the plot arguments `formula =` and `data =`.  This is common, and as long as **R** can interpret it correctly, makes writing code more efficient. 

###
You see that the data is stacked in each year, which sugegsts that `year` is actually a categorical variable.  This means we can use boxplots. 

###
The `boxplot` function can give us an idea of how the data is distributed: 
```{r echo = TRUE}
boxplot(height ~ year, veg.all)
```

###
Titles and axis labels can be specified and are formatted automatically by **R**. 
```{r echo=TRUE}
boxplot(formula = height ~ year, data = veg.all,
        main = "Height of vegetation in cm by year",
        xlab = "survey years",
        ylab = "vegetation height")
```

###
End of section **GRAPHS**
